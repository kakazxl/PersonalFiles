# 分布式协议

## Basic Paxos

采用二阶段提交达成共识，针对单个值达成共识

### 角色

#### 提议者

提议一个值，用于投票表决，不参与投票

#### 接受者

对每个提议的值进行投票，并存储接受的值，一般来说，集群中的所有节点都在扮演接受者的角色，参与共识协商，并接受和存储数据。如果出现节点不可用，允许大部分节点可用下进行共识协商。

#### 学习者

被告知投票的结果，接受达成共识的值，存储保存，不参与投票的过程。一般来说，学习者是数据备份节点

### 协商过程

#### 准备阶段

- 客户端作为提议者，分别向所有接受者发送包含提案编号（数据优先级）的准备请求，只需要携带提案编号即可，不需要指定提议的值。

- 接收者接收到提案后，由于没有通过任何提案，所以返回“尚无提案”的响应，设置提案编号为接收的编号的最大值max，承诺不响应<= max的提案，不通过<max的提案。

#### 接受阶段

- 客户端收到接受者的准备响应之后，根据响应中提案编号最大的提案的值，设置请求中的值。

- 接受者收到提案之后，会根据提案编号进行判断，通过了提案，就提案的值达成共识。

- 当共识达成之后，如果后续有新的提案到达，如果接受者之前有通过提案，那么接受者将承诺，会在准备请求的响应中，包含已经通过的最大编号的提案信息。

- 客户端会根据返回的提案信息，更新请求数据，并将提案数据发送给接受者。接受者判断提案编号决定是否接受。

- 学习者会接受共识后的提案，进行保存。

## Raft算法

本质上说，Raft 算法是通过一切以领导者为准的方式，实现一系列值的共识和各节点日志的一致。Raft实现的是强一致性。

### 角色

#### 跟随者

就相当于普通群众，默默地接收和处理来自领导者的消息，当等待领导者心跳信息超时的时候，就主动站出来，推荐自己当候选人。

#### 候选人

候选人将向其他节点发送请求投票（RequestVote）RPC 消息，通知其他节点来投票，如果赢得了大多数选票，就晋升当领导者。

#### 领导者

处理写请求、管理日志复制和不断地发送心跳信息，通知其他节点存活，不要发起选举。

### 选举流程

- 在没有领导者或者接收领导者消息超时，节点A增加自己的任期编号，并推举自己为候选人，先给自己投上一张选票，然后向其他节点发送请求投票 RPC 消息，请它们选举自己为领导者。

- 其他节点收到选举的RPC之后，会做3个判断
  1. 判断选举任期编号是否比当前编号高 
  2. 判断日志完整性是否比自己高

- 满足条件之后，会将票投给节点A，同时如果自己是领导者，会降级成跟随者。

- 节点A收到超过半数的投票之后就变成新的领导者。

### 日志复制

#### 日志复制流程

- 接收到客户端请求后，领导者基于客户端请求中的指令，创建一个新日志项，并附加到本地日志中。
- 领导者通过日志复制 RPC，将新的日志项复制到其他的服务器。
- 当领导者将日志项，成功复制到大多数的服务器上的时候，领导者会将这条日志项应用到它的状态机中。
- 领导者将执行的结果返回给客户端。
- 当跟随者接收到心跳信息，或者新的日志复制 RPC 消息后，如果跟随者发现领导者已经提交了某条日志项，而它还没应用，那么跟随者就将这条日志项应用到本地的状态机中。

#### 日志同步规则

- 领导者通过日志复制 RPC  消息，发送当前最新日志项到跟随者，这个消息的 PrevLogEntry 值为  7，PrevLogTerm 值为 4。
- 如果跟随者在它的日志中，找不到与 PrevLogEntry 值为 7、PrevLogTerm 值为 4  的日志项，也就是说它的日志和领导者的不一致了，那么跟随者就会拒绝接收新的日志项，并返回失败信息给领导者。
- 这时，领导者会递减要复制的日志项的索引值，并发送新的日志项到跟随者，这个消息的 PrevLogEntry 值为 6，PrevLogTerm 值为 3。
- 如果跟随者在它的日志中，找到了 PrevLogEntry 值为  6、PrevLogTerm 值为 3 的日志项，那么日志复制 RPC 返回成功，这样一来，领导者就知道在 PrevLogEntry 值为  6、PrevLogTerm 值为 3 的位置，跟随者的日志项与自己相同。
- 领导者通过日志复制  RPC，复制并更新覆盖该索引值之后的日志项（也就是不一致的日志项），最终实现了集群各节点日志的一致。

### 成员变更

成员变更可能导致出现两个领导者。

#### 解决方法

- 采用单节点变更的方式。

- 如果并发进行单节点变更时，如果存在分区错误或者节点故障的情况，也会导致集群和出现两个领导者。可以在领导者启动时，创建一个 NO_OP 日志项（也就是空日志项），只有当领导者将 NO_OP 日志项应用后，再执行成员变更请求。

## Gossip协议

二阶段提交协议和 Raft 算法都需要全部节点或者大多数节点正常运行，才能稳定运行；如果希望系统在少数服务节点正常运行的情况下，仍能对外提供稳定服务，这时就需要实现最终一致性，Gossip将信息传播到整个网络中，在一定时间内，使得系统内的所有节点数据一致。

### 直接邮寄（Direct Mail）

就是直接发送更新数据，当数据发送失败时，将数据缓存下来，然后重传。

### 优点

- 实现起来比较容易，数据同步也很及时

### 缺点

- 可能会因为缓存队列满了而丢数据，无法实现最终一致性。

### 反熵（Anti-entropy）

反熵指的是集群中的节点，每隔段时间就随机选择某个其他节点，然后通过互相交换自己的所有数据来消除两者之间的差异，实现数据的最终一致性。

### 缺点

- 执行反熵时通讯成本会很高，不建议在实际场景中频繁执行反熵，并且可以通过引入校验和（Checksum）等机制，降低需要对比的数据量和通讯消息等。

- 相关的节点需要已知，而且节点数量不能太多，如果是一个动态变化或节点数比较多的分布式环境反熵就不适用了。

### 谣言传播（Rumor mongering）

当一个节点有了新数据后，这个节点变成活跃状态，并周期性地联系其他节点向其发送新数据，直到所有的节点都存储了该新数据。

## Quorum NWR

通过 Quorum NWR，可以自定义一致性级别，通过临时调整写入或者查询的方式，当 W + R > N 时，就可以实现强一致性了。

- N 表示副本数，又叫做复制因子（Replication Factor）。也就是说，N 表示集群中同一份数据有多少个副本。

- W，又称写一致性级别（Write Consistency Level），表示成功完成 W 个副本更新，才完成写操作。

- R，又称读一致性级别（Read Consistency Level），表示读取一个数据对象时需要读 R 个副本。

**当 W + R > N 的时候，对于客户端来讲，整个系统能保证强一致性，一定能返回更新后的那份数据。当 W + R <= N 的时候，对于客户端来讲，整个系统只能保证最终一致性，可能会返回旧数据。**

## ZAB协议

能保证操作顺序性的，基于主备模式的原子广播协议。

### 一致性流程

- 在 ZAB 中，写操作必须在主节点上执行。如果客户端访问的节点是备份节点，它会将写请求转发给主节点。

- 当主节点接收到写请求后，它会基于写请求中的指令（也就是 X，Y），来创建一个提案（Proposal），并使用一个唯一的 ID 来标识这个提案。事务标识符是 64 位的 long 型变量，有任期编号 epoch 和计数器 counter 两部分组成，格式为 ，高 32 位为任期编号，低 32 位为计数器：
  1. 任期编号，就是创建提案时领导者的任期编号，需要你注意的是，当新领导者当选时，任期编号递增，计数器被设置为零。比如，前领导者的任期编号为 1，那么新领导者对应的任期编号将为  2。
  2. 计数器，就是具体标识提案的整数，需要你注意的是，每次领导者创建新的提案时，计数器将递增。比如，前一个提案对应的计数器值为  1，那么新的提案对应的计数器值将为 2。
  3. 通过这种方式事务可以唯一标识一个提案，也就是说，事务标识符必须是唯一的、递增的。

- 在创建完提案之后，主节点会基于 TCP 协议，并按照顺序将提案广播到其他节点。这样就能保证先发送的消息，会先被收到，保证了消息接收的顺序性。

- 主节点接收到指定提案的“大多数”的确认响应后，该提案将处于提交状态（Committed），主节点会通知备份节点提交该提案。主节点根据事务标识符大小，按照顺序提交提案，如果前一个提案未提交，此时主节点是不会提交后一个提案的。也就是说，指令 X 一定会在指令 Y 之前提交。

### ZAB选举

ZAB 支持 3 种成员身份（领导者、跟随者、观察者）。

- 领导者（Leader）： 作为主（Primary）节点，在同一时间集群只会有一个领导者。需要你注意的是，所有的写请求都必须在领导者节点上执行。
- 跟随者（Follower）：作为备份（Backup）节点， 集群可以有多个跟随者，它们会响应领导者的心跳，并参与领导者选举和提案提交的投票。需要你注意的是，跟随者可以直接处理并响应来自客户端的读请求，但对于写请求，跟随者需要将它转发给领导者处理。
- 观察者（Observer）：作为备份（Backup）节点，类似跟随者，但是没有投票权，也就是说，观察者不参与领导者选举和提案提交的投票，相当于学习者的身份。

虽然 ZAB 支持 3 种成员身份，但是它定义了 4 种成员状态。

- LOOKING：选举状态，该状态下的节点认为当前集群中没有领导者，会发起领导者选举。
- FOLLOWING ：跟随者状态，意味着当前节点是跟随者。
- LEADING ：领导者状态，意味着当前节点是领导者。
- OBSERVING： 观察者状态，意味着当前节点是观察者。

#### 选举流程

- 当跟随者检测到连接领导者节点的读操作等待超时了，跟随者会变更节点状态，将自己的节点状态变更成 LOOKING，然后发起领导者选举。
- 接着，每个节点会创建一张选票，这张选票是投给自己的，然后各自将选票发送给集群中所有节点。
- 为了选举出数据最完整的节点，对于每一张接收到选票，节点都需要进行领导者 PK，也就将选票提议的领导者和自己提议的领导者进行比较，找出更适合作为领导者的节点，约定的规则如下：

    1. 优先检查任期编号（Epoch），任期编号大的节点作为领导者；
    2. 如果任期编号相同，比较事务标识符的最大值，值大的节点作为领导者；
    3. 如果事务标识符的最大值相同，比较集群 ID，集群 ID 大的节点作为领导者。

- 如果选票提议的领导者，比自己提议的领导者，更适合作为领导者，那么节点将调整选票内容，推荐选票提议的领导者作为领导者。

逻辑时钟（logicclock）（也就是选举的轮次），会影响选票的有效性，具体来说，逻辑时钟大的节点不会接收来自值小的节点的投票信息。