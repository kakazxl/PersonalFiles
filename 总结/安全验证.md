## 安全解决方案

识别、认证、授权、审计、问责

### 身份识别和认证

- 你知道什么（密码、密保问题等）；
- 你拥有什么（门禁卡、安全令牌等）；
- 你是什么（生物特征，指纹、人脸、虹膜等）。

#### 单点登录

单点登录(Single Sign On, SSO)：用户只需要进行一次认证，就可以访问所有的网页、应用和其他产品了。

##### CAS(Central Authentication Service，集中式认证服务)

- CAS 是一个开源的单点登录框架，它不属于某一种单点登录的实现方式，而是提供了一整套完整的落地方案。
- 假如用户现在要访问某个应用，应用需要进行认证，但应用本身不具备认证功能。因此，应用将用户重定向至认证中心的页面。
- 用户在认证中心页面进行认证操作。如果用户之前已经在其他应用进行过认证了，那么认证中心可以直接识别用户身份，免去用户再次认证的过程。
- 认证完成后，认证中心将认证的凭据，有时会加上用户的一些信息，一起返回给客户端。
- 客户端将凭据和其他信息发送给应用。
- 应用收到凭据后，可以通过签名的方式，验证凭据的有效性。或者，应用也可以直接和认证中心通信，验证凭据并获取用户信息，完成用户验证。

##### JWT（JSON Web Token）

是一种非常轻量级的单点登录流程。它会在客户端保存一个凭证信息，之后在你每一次登录的请求中都带上这个凭证，将其作为登录状态的依据。JWT 的好处在于不需要应用服务端去额外维护 Cookie 或者 Session 了。但是，正是因为它将登录状态落到了客户端，所以我们无法进行注销等操作了。

##### OAuth

主要特点是授权，也是我们通常用 QQ、微信登录其他应用时所采用的协议。通过 OAuth，用户在完成了认证中心的登录之后，应用只能够验证用户确实在第三方登录了。但是，想要维持应用内的登录状态，应用还是得颁发自己的登录凭证。这也就是为什么 QQ 授权后，应用还需要绑定你的手机号码。这也就意味着，应用是基于 QQ 的信息创建了一个自身的账号。

##### OpenID（Open Identity Document）

和 OAuth 的功能基本一致。但是，OpenID 不提供授权的功能。最常见的，当我们需要在应用中使用微信支付的时候，应用只需要收集支付相关的信息即可，并不需要获取用户的微信头像。

### 授权

在确认完“你是你”之后，下一个需要明确的问题就是“你能做什么”。毫无疑问，在系统或者应用中，我们的操作都会受到一定的限制。比如，某些文件不可读，某些数据不可修改。这就是授权机制。

#### 访问控制

一个主体请求一个客体，这个请求的授权由访问控制来完成。

- 主体：请求的发起者。主体可以是用户，也可以是进程、应用、设备等任何发起访问请求的来源。
- 客体：请求的接收方，一般是某种资源。比如某个文件、数据库，也可以是进程、设备等接受指令的实体。
- 请求：主体对客体进行的操作。常规的是读、写和执行，也可以进一步细分为删除、追加等粒度更细的操作。

访问控制机制

##### DAC（Discretionary Access Control，自主访问控制）

DAC 就是让客体的所有者来定义访问控制规则。

- 优点：在 DAC 中，访问控制的规则维护完全下发到了所有者手上，管理员在理论上不需要对访问控制规则进行维护。因此，DAC 具备很高的灵活性，维护成本也很低。
- 缺点：尽管 DAC 降低了管理员的工作难度，但是会增加整体访问控制监管的难度，以至于安全性完全取决于所有者的个人安全意识。

##### role-BAC（role Based Access Control，基于角色的访问控制）

role-BAC 就是将主体划分为不同的角色，然后对每个角色的权限进行定义。role-BAC 是防止权限泛滥，实现最小特权原则的经典解决方案。

##### rule-BAC（rule Based Access Control，基于规则的访问控制）

rule-BAC 就是制定某种规则，将主体、请求和客体的信息结合起来进行判定。

##### MAC（Mandatory Access Control，强制访问控制）

MAC 是一种基于安全级别标签的访问控制策略。为了保证机密性，MAC 不允许低级别的主体读取高级别的客体、不允许高级别的主体写入低级别的客体；为了保证完整性，MAC 不允许高级别的主体读取低级别的客体，不允许低级别的主体写入高级别的客体。

### 审计和问责

当你在授权下完成操作后，安全需要检查一下“你做了什么”，这个检查的过程就是审计。当发现你做了某些异常操作时，安全还会提供你做了这些操作的“证据”，让你无法抵赖，这个过程就是问责。

## 加密算法

### 对称加密算法

所谓对称加密，代表加密和解密使用的是同一个密钥

- AES算法：提供了 128 位、192 位和 256 位三种密钥长度。通常情况下，我们会使用 128 位的密钥，来获得足够的加密强度，同时保证性能不受影响。目前，AES 是国际上最认可的密码学算法

### 非对称加密算法

非对称加密代表加密和解密使用不同的密钥。具体的加解密过程就是，发送方使用公钥对信息进行加密，接收方收到密文后，使用私钥进行解密。

- RSA：RSA 的数学难题是两个大质数 p、q 相乘的结果 n 很容易计算，但是根据 n 去做质因数分解得到 p、q，则需要很大的计算量。它的主要优势就是性能比较快，但想获得较高的加密强度，需要使用很长的密钥。

### 散列算法

大量的应用都在使用 MD5 或者 SHA 算法计算一个唯一的 id。比如 Git 中的提交记录、文件的完整性校验、各种语言中字典或者 Map 的实现等等。

- MD5（消息摘要算法，Message-Digest Algorithm 5）。MD5 可以用来生成一个 128 位的消息摘要，它是目前应用比较普遍的散列算法。
- SHA-256 普遍被认为是相对安全的散列算法，也是我最推荐你使用的散列算法。

使用散列算法的时候，要注意加“盐”。所谓“盐”，就是一串随机的字符，是可以公开的。将用户的密码“盐”进行拼接后，再进行散列计算，这样，即使两个用户设置了相同的密码，也会拥有不同的散列值。

## Web安全

### XSS攻击(Cross0Site Scripting, 跨站脚本攻击)

黑客可以在你的浏览器中，插入一段恶意的 JavaScript 脚本，从而窃取你的隐私信息或者仿冒你进行操作。

#### 反射型XSS

黑客通过诱导的方式让用户点击某个链接，通过网页漏洞，网页被填入黑客定义的脚本，使得用户浏览器最终执行的是黑客的脚本。

#### DOM(文档对象模型)XSS

在基于 DOM 的 XSS 中，黑客通过诱导的方式让用户点击某个链接，通过修改DOM，执行指定的JS脚本，而不用经过服务端。

#### 持久型 XSS

持久型 XSS 将恶意的 JavaScript 脚本写入到了正常的服务端数据库中，因此，只要用户正常的使用业务功能，就会被注入 JavaScript 脚本。

#### XSS的防护措施

##### 验证输出：

在需要输出的时候去进行验证，即当需要展示的时候，我们再对内容进行验证，这样我们就能够根据不同的环境去采取不同的保护方案了。

##### 白名单检测过滤：

- 在有输入的地方进行白名单过滤
- 对某些敏感词汇通过白名单的形式进行过滤

##### CSP(Content Security Policy，内容安全策略)

所谓 CSP，就是在服务端返回的 HTTP header 里面添加一个 Content-Security-Policy 选项，然后定义资源的白名单域名。浏览器就会识别这个字段，并限制对非白名单资源的访问。

### SQL注入

在应用拼接 SQL 语句的时候，去篡改正常的 SQL 语意，从而执行黑客所控制的 SQL 查询功能。这个过程，就相当于黑客“注入”了一段 SQL 代码到应用中。这就是我们常说的 SQL 注入。

#### SQL注入的危害

- 绕过验证
- 任意篡改数据
- 窃取数据
- 消耗资源

#### SQL注入防护

- 使用PreparedStatement
- 使用参数化sql
- 使用存储过程
- 验证输入

### CSRF/SSRF(Cross-Site Request Forgery，跨站请求伪造)/ (Server Side Request Forgery，服务端请求伪造)

#### CSRF

CSRF采用Cookie认证，绕过了用户认证，仿冒用户去进行一些功能操作的请求，比如修改密码、转账等等，进行未授权的操作

##### CSRF防护

- 采用token：在接口中，加入一个黑客无法猜到的参数，就可以有效防止 CSRF 了。每一次正常的接口调用，都会携带不同的 CSRF Token。
- 通过二次验证进行防护：在进行转账等操作的时候，再进行有一次身份验证。

#### SSRF

SSRF通过服务端发起伪造的内网请求，从而获取到内网数据。实现内网探测和文件读取等。

##### SSRF防护

###### 采用白名单限制

- 对协议和资源类型进行限制
- 尽量使用post接口，避免get接口使用，发起 POST 请求，需要在发起 HTTP 请求的时候进行配置。
- 为其他业务提供的服务接口，最好每次都进行验证。通过 SSRF，黑客只能发起请求，并不能获取到服务端存储的验证信息（如认证的 key 和 secret 等。因此，只要接受代理请求的端对每次请求都进行完整的验证，黑客无法成功通过验证。

### WAF（Web Application Firewall，Web 应用防护系统）

三种模式：透明代理、反向代理和插件模式。

#### 透明代理

在客户端和服务端通信不需要作出任何改变的情况下，对 HTTP 流量进行请求和转发。在这个过程中，为了解密 HTTPS 流量，WAF 必须和服务端同步 HTTPS 对称密钥。

- 优点：容易部署，不需要修改客户端和服务端
- 缺点：透明代理本身不是一个 Web 服务，所以它无法修改或者响应 HTTP 的请求，只能够控制请求的通过或者拒绝。正因为如此，它也无法实现 Web 服务所提供的认证、内容过滤等功能。

#### 反向代理

反向代理要求客户端将请求的目标地址指向 WAF，而不是服务端。在反向代理工作模式中，服务端接收的请求，实际上也是由 WAF 发起的。在这个过程中，WAF 本身就相当于一个 Web 服务，只不过对所有的 HTTP 请求都进行了转发。

##### 优点：

- 反向代理 WAF 本质上是一个 Web 服务，所以 HTTPS 证书可以直接部署在 WAF 上。WAF 在对 HTTPS 流量解密之后，就可以在内网中用 HTTP 的形式，向服务端发起代理请求了。
- 反向代理WAF 可以充当一个前置的认证平台，对所有请求进行身份校验和身份管理。
- 所以反向代理 WAF 对服务端的隔离也更加彻底。

##### 缺点：

- 性能开销更大
- 反向代理 WAF 一旦宕机，就无法响应客户端的任何请求。

#### 插件模式

采用AOP编程，和服务端强耦合

##### 优点：

- 部署简单
- 由服务端提供高可用

##### 缺点：

- 对服务端性能产生影响
- 升级流程复杂